### JS常识

------

#### 一、书写位置

+ 内部JavaScript

  直接写在html文件中，使用script标签包裹起来

  注：将script放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载HTML，如果先加载的JS希望修改其下方的HTMl，那么它可能会由于HTML尚未加载而失效。

+ 引入外部js文件

  在body中通过script标签引入

  ```html
  <body>
      <script src="某某.js"></script>
  </body>
  ```



#### 二、变量、常量与数组

+ ES6须知

  > 在ES6（ECMAScript 6）中，变量的声明方式发生了显著的变化，主要引入了`let`和`const`两种新的关键字，并对原有的`var`关键字的行为进行了补充和明确。以下是ES6中变量声明的主要变化：
  >
  > ### 一、`let`关键字的引入
  >
  > 1. **块级作用域**：使用`let`声明的变量具有块级作用域，只在其所在的代码块（如函数体、循环体、条件语句块等）内有效。这意味着在块外部无法访问块内部使用`let`声明的变量。
  > 2. **不存在变量提升**：与`var`不同，`let`声明的变量不会被提升到其作用域的顶部。因此，在变量声明之前访问该变量会抛出错误，这称为暂时性死区（Temporal Dead Zone，TDZ）。
  > 3. **不允许重复声明**：在同一作用域内，不允许使用`let`重复声明同一个变量。
  >
  > ### 二、`const`关键字的引入
  >
  > 1. **块级作用域**：与`let`类似，`const`声明的变量也具有块级作用域。
  > 2. **必须赋值**：使用`const`声明变量时，必须同时为其赋值。一旦赋值后，变量的值就不能再被重新赋值（对于基本数据类型而言）。但如果`const`声明的是一个对象或数组，虽然其内存地址不能被改变，但对象或数组的内容是可以修改的。
  > 3. **不存在变量提升**：与`let`一样，`const`声明的变量也不会被提升到其作用域的顶部，存在暂时性死区。
  > 4. **不允许重复声明**：在同一作用域内，不允许使用`const`重复声明同一个变量。
  >
  > ### 三、`var`关键字的行为明确
  >
  > 1. **函数作用域与全局作用域**：在ES6之前，使用`var`声明的变量在函数内部具有函数作用域（也称为局部作用域），在函数外部具有全局作用域。此外，`var`声明的变量存在变量提升现象，即变量可以在声明之前被访问（但值为`undefined`）。
  > 2. **重复声明不报错**：在ES6之前，使用`var`可以在同一作用域内重复声明同一个变量，而不会引发错误。但在ES6中，由于`let`和`const`的引入，这种做法被视为不良实践。

+ 变量声明

  ```js
  // 赋值
  let age = 18
  // 修改
  age = 20
  ```

+ 常量

  当某个变量永远不会改变时，就可以使用const来声明；常量不允许重新赋值，故声明时必须赋值

+ 数组的声明、赋值与使用

  ```js
  // 声明与赋值
  let arr = ['小刚','小红','小明','小丽']
  // 数组的使用
  console.log(arr[0])
  // 数组length属性
  console.log(arr.length)  // 4
  ```

  

#### 三、数据类型

+ 数字类型（number）：数据类型在运算错误时，会打印NaN表示运算不符合逻辑且NaN的任何操作都会返回NaN，例如：除0，类型不匹配

  > console.log('你好'+2)       NaN
  >
  > console.log(NaN + 2)      NaN

+ 字符串类型

  + 字符串拼接：使用+运算符，可以实现字符串之间的连接

  + 模板字符串：对于使用反引号``包括起来的字符串中${变量名}相当于C语言中的占位符

    > let  age  =  18
    >
    > 在字符串声明时，可以直接使用``将字符串括起来，该字符串可以直接加入${变量名}做替换

+ boolean类型：有固定的值为true与false两个，且在其他类型做强制转换时，也有对应的真或假

+ undefined类型：只声明变量，不对变量进行赋值，变量默认为undefined，在开发过程中经常声明一个变量，等待传送过来的数据，当需要判断一个数据是否有值，可以通过检测该变量是否为undefined，就可以判断用户是否有数据传送过来

+ null：官方解释null为尚未创建的对象，简言之为将来有一个变量存放的为一个对象，但对象还没创建好，值为null

+ 类型检测：typeof  变量名，可以检测一个变量的类型

#### 四、类型转换

+ 隐式转换

  +号两边只要有一个是字符串，都会把另一个转换为字符串，除了加号以外的算术运算符都会将数据转换为数字类型，若不能转换为数字类型做运算会输出NaN

+ 强制转换

  ```js
  let str = "123"
  // 转换为数字型，后两种类型的用法请使用时自行查询
  let num = Number(str)  
  let num = parseInt(str)  
  let num = parseFloat(str) 
  ```

+ 运算符优先级

  小括号 > 一元运算符(++,--,!) > 算术运算符 > 关系运算符(>,>=,<,<=) > 相等运算符(==,!=,全等,不全等) > 逻辑



#### 五、分支与循环

+ 分类

  + 分支：if分支、if-else分支、if-else if-else分支、switch分支语句
  + 三元运算符：与java三目运算符用法一样
  + 循环：while循环、for循环
  + 退出循环：break与continue

+ while循环

  ```js
  let i = 1
  while(i<3){
      document.write("循环")
      i++
  }
  ```

+ for循环

  ```js
  for(let i = 0; i < 3; i++){
      
  }
  
  // 遍历数组
  let arr = ["张三","李四","王五","赵六"]
  for(let i = 0; i < arr.length; i++){
      console.log(arr[i])
  }
  ```

  

#### 六、数组操作

```js
// 1. 数组修改
arr[0] = "你好"

// 2. 数组新增
arr.push(新增内容)   // 向数组末尾添加数据，并返回数组新长度
arr.unshift(新增内容) // 向数组开头添加元素，并返回数组长度

// 3. 删除数组中数据
arr.pop()   // 删除数组中最后一个元素，并返回该元素的值
arr.shift   // 删除第一个元素
```



### 函数

------

